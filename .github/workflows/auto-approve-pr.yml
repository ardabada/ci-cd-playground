name: main→feat guard + auto-approve

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, labeled, unlabeled]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - name: Validate + approve + label + comment (non-failing)
        id: bot
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        shell: bash
        run: |
          set -euo pipefail

          LABEL="main-to-feat"
          MARKER="<!-- main-to-feat-bot -->"

          # 7) If it's not a PR into feat/*, do nothing
          if [[ "$BASE_REF" != feat/* ]]; then
            echo "Base is '$BASE_REF' (not feat/*). Doing nothing."
            exit 0
          fi

          # Helper: upsert a single bot comment (edit if exists; otherwise create)
          upsert_comment() {
            local body="$1"

            local cid
            cid="$(gh api "repos/$REPO/issues/$PR/comments?per_page=100" --jq \
              ".[] | select(.user.login==\"github-actions[bot]\" and (.body | contains(\"$MARKER\"))) | .id" \
              | head -n 1 || true)"

            if [[ -n "${cid:-}" ]]; then
              gh api -X PATCH "repos/$REPO/issues/comments/$cid" -f "body=$body" >/dev/null
            else
              gh api -X POST "repos/$REPO/issues/$PR/comments" -f "body=$body" >/dev/null
            fi
          }

          ensure_label_present() {
            gh api -X POST "repos/$REPO/issues/$PR/labels" -f "labels[]=$LABEL" >/dev/null 2>&1 || true
          }

          ensure_label_absent() {
            gh api -X DELETE "repos/$REPO/issues/$PR/labels/$LABEL" >/dev/null 2>&1 || true
          }

          # PR metadata
          pr_json="$(gh api "repos/$REPO/pulls/$PR")"
          draft="$(echo "$pr_json" | jq -r '.draft')"
          mergeable="$(echo "$pr_json" | jq -r '.mergeable')"               # true/false/null
          mergeable_state="$(echo "$pr_json" | jq -r '.mergeable_state')"   # clean/dirty/blocked/unknown/...

          # PR commits
          commits_json="$(gh api "repos/$REPO/pulls/$PR/commits?per_page=100")"
          commits_count="$(echo "$commits_json" | jq 'length')"

          valid="false"
          why_invalid=""

          if [[ "$commits_count" -ne 1 ]]; then
            why_invalid="Expected exactly 1 commit (merge-only sync). Found $commits_count commits."
          else
            sha="$(echo "$commits_json" | jq -r '.[0].sha')"
            parents_count="$(echo "$commits_json" | jq '.[0].parents | length')"

            if [[ "$parents_count" -ne 2 ]]; then
              why_invalid="Expected the single commit to be a merge commit with 2 parents. Found parents=$parents_count."
            else
              p1="$(echo "$commits_json" | jq -r '.[0].parents[0].sha')"
              p2="$(echo "$commits_json" | jq -r '.[0].parents[1].sha')"

              compare_status() {
                local base="$1"
                local head="$2"
                gh api "repos/$REPO/compare/$base...$head" --jq '.status'
              }

              base_p1="$(compare_status "$BASE_REF" "$p1" 2>/dev/null || echo "error")"
              base_p2="$(compare_status "$BASE_REF" "$p2" 2>/dev/null || echo "error")"
              main_p1="$(compare_status "main" "$p1" 2>/dev/null || echo "error")"
              main_p2="$(compare_status "main" "$p2" 2>/dev/null || echo "error")"

              is_base_on_p1="false"; is_base_on_p2="false"
              is_main_on_p1="false"; is_main_on_p2="false"

              [[ "$base_p1" == "behind" || "$base_p1" == "identical" ]] && is_base_on_p1="true"
              [[ "$base_p2" == "behind" || "$base_p2" == "identical" ]] && is_base_on_p2="true"
              [[ "$main_p1" == "behind" || "$main_p1" == "identical" ]] && is_main_on_p1="true"
              [[ "$main_p2" == "behind" || "$main_p2" == "identical" ]] && is_main_on_p2="true"

              if { [[ "$is_base_on_p1" == "true" && "$is_main_on_p2" == "true" ]] || [[ "$is_base_on_p2" == "true" && "$is_main_on_p1" == "true" ]]; }; then
                valid="true"
              else
                why_invalid="Merge commit parents do not match a pure sync. One parent must come from '$BASE_REF' history and the other from 'main' history.
BASE...p1=$base_p1, BASE...p2=$base_p2
main...p1=$main_p1, main...p2=$main_p2"
              fi
            fi
          fi

          # 6) Label management
          if [[ "$valid" == "true" ]]; then
            ensure_label_present
          else
            ensure_label_absent
          fi

          # 2) Auto-approve (only if clean + mergeable)
          approved="false"
          approve_reason=""

          if [[ "$valid" == "true" ]]; then
            if [[ "$draft" == "true" ]]; then
              approve_reason="PR is draft."
            elif [[ "$mergeable" == "true" && "$mergeable_state" == "clean" ]]; then
              set +e
              gh pr review "$PR" --approve -b "Auto-approved: merge-only sync of 'main' into '$BASE_REF'." >/dev/null 2>&1
              rc=$?
              set -e
              if [[ $rc -eq 0 ]]; then
                approved="true"
              else
                approve_reason="GitHub rejected auto-approval (branch protection/bot approval policy/etc.)."
              fi
            else
              approve_reason="PR is not clean/mergeable yet (mergeable=$mergeable, state=$mergeable_state)."
            fi
          fi

          # Build comment bodies safely
          if [[ "$valid" == "true" ]]; then
            if [[ "$approved" == "true" ]]; then
              body="$MARKER
✅ **Valid merge-only sync PR**: 'main' → '$BASE_REF'

- Label: '$LABEL' ensured
- Review: **Auto-approved**

_(This comment is maintained by the bot and will be updated, not duplicated.)_"
              upsert_comment "$body"
            else
              body="$MARKER
⚠️ **Valid merge-only sync PR**: 'main' → '$BASE_REF' — but **auto-approval was not applied**

**Summary**
- Label: '$LABEL' ensured
- Auto-approve: not performed
- Reason: $approve_reason
- Mergeability: mergeable='$mergeable', state='$mergeable_state'"
              upsert_comment "$body"
            fi
          else
            body="$MARKER
ℹ️ This PR targets '$BASE_REF' but does **not** look like a pure “merge main → feat” sync PR.

**What I see**
- Head: '$HEAD_REF'
- Base: '$BASE_REF'
- Commits: $commits_count

**Why it’s not considered a sync PR**
$why_invalid

If this is meant to be a sync PR: create a branch from '$BASE_REF', merge 'main' into it (resolve conflicts), and open a PR containing **only that merge commit**."
            upsert_comment "$body"
          fi

          # 4) Never fail the pipeline
          exit 0
